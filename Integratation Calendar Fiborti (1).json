{
  "name": "Integratation Calendar Fiborti",
  "nodes": [
    {
      "parameters": {
        "options": {
          "systemMessage": "Disponibilidad/Fechas: Si el usuario no especifica el año, asume el año actual sin pedir confirmación.\n\nUsa el tool Code check_availability para extraer persona, timeMin y timeMax. Después, llama a los nodos Get many events correspondientes pasando After = timeMin y Before = timeMax.\n\nNUEVO - Múltiples colaboradores: \n- El sistema ahora puede recibir múltiples colaboradores seleccionados con checkboxes\n- Cuando hay múltiples colaboradores, consulta TODOS sus calendarios individualmente\n- Analiza los conflictos entre calendarios para encontrar horarios donde TODOS estén libres\n- Muestra claramente qué colaboradores tienen conflictos en cada horario\n- Para agendamiento, solo permite agendar cuando hay UN solo colaborador seleccionado\n\nMapeo de calendarios para consultas:\n- Danny: Get many events Danny Cen (usa timeMin y timeMax)\n- Mauricio: Get many events Mauricio (usa timeMin y timeMax) \n- Fernando: Get many events Fernando (usa timeMin y timeMax)\n- Emilio: Get many events Emilio (usa timeMin y timeMax)\n- Fiborti Team: Get many events Fiborti (usa timeMin y timeMax)\n\nAgendamiento: Para agendar citas, usa el tool Code book_appointment primero para preparar los datos, luego usa el nodo Create an event correspondiente según la persona:\n- Danny: Create an event Danny Cen  \n- Mauricio: Create an event Mauricio\n- Fernando: Create an event Fernando\n- Emilio: Create an event Emilio\n- Fiborti Team/Equipos: Create an event Fiborti\n\nAnálisis de disponibilidad múltiple:\n1. Consulta cada calendario individual\n2. Compara los horarios para encontrar intersecciones libres\n3. Reporta claramente los horarios donde todos están disponibles\n4. Indica específicamente qué colaboradores tienen conflictos\n5. Solo permite agendamiento directo si es un solo colaborador\n\nNo hagas preguntas de confirmación si la fecha es válida con año asumido."
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.1,
      "position": [
        208,
        -160
      ],
      "id": "462268bf-c8e7-4cbe-bbcd-9ce5ad3ddf69",
      "name": "AI Agent"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
      "typeVersion": 1,
      "position": [
        -160,
        352
      ],
      "id": "520b97c5-a719-47da-b3c9-56c3a0baff95",
      "name": "Google Gemini Chat Model",
      "credentials": {
        "googlePalmApi": {
          "id": "DIM4iEAJQaEFRoEd",
          "name": "Google Gemini(PaLM) Api account"
        }
      }
    },
    {
      "parameters": {},
      "type": "@n8n/n8n-nodes-langchain.memoryBufferWindow",
      "typeVersion": 1.3,
      "position": [
        -16,
        368
      ],
      "id": "dee51d7c-51f9-40b6-8813-1608cee6604d",
      "name": "Simple Memory"
    },
    {
      "parameters": {
        "jsCode": "/**\n * Code (Tool) - check_availability (ES + hora) - ACTUALIZADO para múltiples colaboradores\n * Entradas posibles:\n * - $json.colaboradores -> [\"Danny\", \"Mauricio\"] | [\"Fernando\"] | [\"Fiborti Team\"] | ...\n * - $json.persona        -> \"Danny\" | [\\\"Danny\\\",\\\"Mauricio\\\"] | \"Fernando Fiborti\" | \"Fiborti Team\" | ... (fallback)\n * - $json.fecha          -> \"YYYY-MM\" | \"YYYY-MM-DD\" | texto libre (ej. \"15 de agosto\")\n * - $json.query          -> texto libre\n *\n * Salida:\n * { persona:[...], fecha?, hora?, timeMin, timeMax }\n */\n\n// ---------- helpers ----------\nfunction uniq(arr) { return [...new Set(arr)]; }\nfunction stripDiacritics(s) { return s.normalize('NFD').replace(/\\p{Diacritic}/gu, ''); }\nfunction canon(s) { return stripDiacritics(String(s || '').trim().toLowerCase()); }\n\nconst TZ = 'America/Merida';\n\n// Catálogo de calendarios admitidos (alias -> nombre canónico mostrado)\nconst PERSON_CANON = {\n  // Danny\n  'danny': 'Danny',\n  'danny cen': 'Danny',\n\n  // Mauricio\n  'mauricio': 'Mauricio',\n  'mauricio leon': 'Mauricio',\n\n  // Fernando (incluye typo común)\n  'fernando': 'Fernando',\n  'fernando fiborti': 'Fernando',\n  'fenando': 'Fernando',\n  'fenando fiborti': 'Fernando',\n\n  // Emilio\n  'emilio': 'Emilio',\n  'emilio fiborti': 'Emilio',\n\n  // Equipo\n  'fiborti team': 'Fiborti Team',\n  'team fiborti': 'Fiborti Team',\n  'equipo fiborti': 'Fiborti Team',\n  'calendario fiborti': 'Fiborti Team',\n  // Equipos específicos\n  'team desarrolladores a': 'Team Desarrolladores A',\n  'team desarrolladores b': 'Team Desarrolladores B',\n  'equipo desarrolladores a': 'Team Desarrolladores A',\n  'equipo desarrolladores b': 'Team Desarrolladores B',\n};\nconst DISPLAY_NAMES = uniq(Object.values(PERSON_CANON));\n\nfunction mapToPerson(value) {\n  const c = canon(value);\n  if (PERSON_CANON[c]) return PERSON_CANON[c];\n  const tokens = c.split(/\\s+/).filter(Boolean);\n  if (tokens.length > 1) {\n    const combos = [\n      tokens.join(' '),\n      tokens.slice(-2).join(' '),\n      tokens.slice(-1)[0],\n    ];\n    for (const t of combos) if (PERSON_CANON[t]) return PERSON_CANON[t];\n  }\n  return null;\n}\n\nfunction parsePersons(input) {\n  if (!input) return [];\n  if (Array.isArray(input)) return uniq(input.map(mapToPerson).filter(Boolean));\n  if (typeof input === 'string') {\n    const parts = input.split(/,|\\\\/| y | e /i).map(s => s.trim()).filter(Boolean);\n    if (parts.length > 1) return uniq(parts.map(mapToPerson).filter(Boolean));\n    const mapped = mapToPerson(input);\n    return mapped ? [mapped] : [];\n  }\n  return [];\n}\n\n// ---- parsing fechas/horas en español ----\nconst MONTHS = {\n  'enero': 0, 'febrero': 1, 'marzo': 2, 'abril': 3, 'mayo': 4, 'junio': 5,\n  'julio': 6, 'agosto': 7, 'septiembre': 8, 'setiembre': 8, 'octubre': 9,\n  'noviembre': 10, 'diciembre': 11\n};\n\nfunction parseSpanishDateAndTime(text) {\n  const t = canon(text);\n\n  // Relativos\n  const now = new Date();\n  if (/\\bhoy\\b/.test(t)) return { date: new Date(now.getFullYear(), now.getMonth(), now.getDate()) };\n  if (/\\bmanana\\b/.test(t) || /\\bmaÃ±ana\\b/.test(text)) {\n    const d = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1);\n    return { date: d };\n  }\n  if (/\\bpasado\\s+manana\\b/.test(t) || /\\bpasado\\s+maÃ±ana\\b/.test(text)) {\n    const d = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 2);\n    return { date: d };\n  }\n\n  // Formatos ISO ya soportados\n  let m = t.match(/\\b(20\\d{2})-(0[1-9]|1[0-2])-(0[1-9]|[12]\\d|3[01])\\b/);\n  if (m) return { date: new Date(Number(m[1]), Number(m[2]) - 1, Number(m[3])) };\n\n  m = t.match(/\\b(20\\d{2})-(0[1-9]|1[0-2])\\b/);\n  if (m) return { ym: { y: Number(m[1]), m: Number(m[2]) - 1 } };\n\n  // DD/MM/YYYY o DD-MM-YYYY\n  m = t.match(/\\b([0-3]?\\d)[\\/-]([01]?\\d)[\\/-](20\\d{2})\\b/);\n  if (m) return { date: new Date(Number(m[3]), Number(m[2]) - 1, Number(m[1])) };\n\n  // DD/MM o DD-MM (asume año actual)\n  m = t.match(/\\b([0-3]?\\d)[\\/-]([01]?\\d)\\b/);\n  if (m) return { date: new Date(now.getFullYear(), Number(m[2]) - 1, Number(m[1])) };\n\n  // \"15 de agosto de 2025\" | \"15 de agosto\"\n  m = t.match(/\\b([0-3]?\\d)\\s+de\\s+([a-záéíóúñ]+)(?:\\s+de\\s+(20\\d{2}))?\\b/i);\n  if (m) {\n    const day = Number(m[1]);\n    const monthName = canon(m[2]);\n    const year = m[3] ? Number(m[3]) : now.getFullYear();\n    if (MONTHS.hasOwnProperty(monthName)) {\n      return { date: new Date(year, MONTHS[monthName], day) };\n    }\n  }\n\n  // \"agosto 2025\" | \"agosto\"\n  m = t.match(/\\b([a-záéíóúñ]+)\\s+(20\\d{2})\\b/i);\n  if (m) {\n    const monthName = canon(m[1]);\n    const year = Number(m[2]);\n    if (MONTHS.hasOwnProperty(monthName)) {\n      return { ym: { y: year, m: MONTHS[monthName] } };\n    }\n  }\n  m = t.match(/\\b(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|setiembre|octubre|noviembre|diciembre)\\b/i);\n  if (m) {\n    const monthName = canon(m[1]);\n    return { ym: { y: now.getFullYear(), m: MONTHS[monthName] } };\n  }\n\n  return {};\n}\n\nfunction parseTime(text) {\n  const t = canon(text);\n\n  // HH:MM(am|pm)? | HH(am|pm)? | 24h\n  let m = t.match(/\\b([01]?\\d|2[0-3])[:.]?([0-5]\\d)?\\s*(am|pm)?\\b/);\n  if (!m) return null;\n\n  let hour = Number(m[1]);\n  const minute = m[2] ? Number(m[2]) : 0;\n  const suffix = m[3];\n\n  if (suffix === 'am') {\n    if (hour === 12) hour = 0;\n  } else if (suffix === 'pm') {\n    if (hour < 12) hour += 12;\n  }\n  return { hour, minute };\n}\n\nfunction monthRange(base) {\n  const y = base.getFullYear();\n  const m = base.getMonth();\n  return {\n    timeMin: new Date(y, m, 1, 0, 0, 0, 0).toISOString(),\n    timeMax: new Date(y, m + 1, 0, 23, 59, 59, 999).toISOString(),\n  };\n}\n\nfunction dayRange(base) {\n  const y = base.getFullYear();\n  const m = base.getMonth();\n  const d = base.getDate();\n  return {\n    timeMin: new Date(y, m, d, 0, 0, 0, 0).toISOString(),\n    timeMax: new Date(y, m, d, 23, 59, 59, 999).toISOString(),\n  };\n}\n\nfunction hourRange(base, hour, minute) {\n  const y = base.getFullYear();\n  const m = base.getMonth();\n  const d = base.getDate();\n  const start = new Date(y, m, d, hour, minute || 0, 0, 0);\n  const end = new Date(start.getTime() + 60 * 60 * 1000); // 1h\n  return { timeMin: start.toISOString(), timeMax: end.toISOString() };\n}\n\n// ---------- entrada robusta ----------\nconst inItem = ($input.first && $input.first()) ? ($input.first().json || {}) : {};\nconst body = { ...inItem, ...$json };\n\n// NUEVO: Priorizar el campo colaboradores (array) sobre persona\nlet personas = [];\n\n// 1. Intentar obtener de colaboradores (nuevo formato)\nif (body.colaboradores && Array.isArray(body.colaboradores)) {\n  personas = parsePersons(body.colaboradores);\n}\n\n// 2. Fallback al campo persona (formato anterior)\nif (personas.length === 0 && body.persona) {\n  personas = parsePersons(body.persona);\n}\n\nlet fechaRaw = (typeof body.fecha === 'string') ? body.fecha : undefined;\n\n// Extraer de cualquier campo si falta algo\nconst textRaw = JSON.stringify(body || {});\nif (personas.length === 0) {\n  // buscar alias en todo el texto\n  const t = canon(textRaw);\n  const found = [];\n  for (const alias of Object.keys(PERSON_CANON)) {\n    const pattern = new RegExp(`\\\\b${alias.replace(/[.*+?^${}()|[\\\\\\\\\\]\\\\\\\\\\\\\\\\]/g, '\\\\\\\\\\\\\\\\$&')}\\\\b`, 'i');\n    if (pattern.test(t)) found.push(PERSON_CANON[alias]);\n  }\n  personas = uniq(found);\n}\n\nconst { date, ym } = parseSpanishDateAndTime(fechaRaw || textRaw);\nconst timeMatch = parseTime(fechaRaw || textRaw);\n\n// Validaciones\nif (personas.length === 0) {\n  throw new Error(`Parámetro \"colaboradores\" o \"persona\" faltante o no reconocido. Usa alguno de: ${DISPLAY_NAMES.join(', ')}.`);\n}\n\nlet outFecha;  // YYYY-MM-DD si aplica\nlet timeMin, timeMax;\n\nif (date) {\n  outFecha = `${date.getFullYear()}-${String(date.getMonth()+1).padStart(2,'0')}-${String(date.getDate()).padStart(2,'0')}`;\n  if (timeMatch) {\n    const range = hourRange(date, timeMatch.hour, timeMatch.minute || 0);\n    timeMin = range.timeMin;\n    timeMax = range.timeMax;\n  } else {\n    const range = dayRange(date);\n    timeMin = range.timeMin;\n    timeMax = range.timeMax;\n  }\n} else if (ym) {\n  const base = new Date(ym.y, ym.m, 1);\n  const range = monthRange(base);\n  timeMin = range.timeMin;\n  timeMax = range.timeMax;\n} else {\n  // fallback: mes actual\n  const base = new Date();\n  const range = monthRange(base);\n  timeMin = range.timeMin;\n  timeMax = range.timeMax;\n}\n\nconst assumedYear =\n  !!date && !(/\\b20\\d{2}\\b/.test((fechaRaw || textRaw))) ? true : false;\n\nreturn JSON.stringify({\n  persona: personas,      // Array de personas normalizadas\n  fecha: outFecha,        // \"2025-08-15\" si se detectó día\n  hora: timeMatch ? `${String(timeMatch.hour).padStart(2,'0')}:${String(timeMatch.minute||0).padStart(2,'0')}` : undefined,\n  timeMin,\n  timeMax,\n  timeZone: TZ,\n  assumedYear,\n  isMultiple: personas.length > 1  // Flag para indicar consulta múltiple\n});"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.3,
      "position": [
        288,
        560
      ],
      "id": "d46e1e27-47cd-42ca-938c-523128d89a6c",
      "name": "Code check_availability"
    },
    {
      "parameters": {
        "jsCode": "/**\n * INPUT esperado desde el AI Agent:\n * {\n *   \"persona\": \"Danny\" | \"Mauricio\" | \"Fernando\" | \"Emilio\" | \"Fiborti Team\",\n *   \"fecha\": \"YYYY-MM-DD\",\n *   \"hora_inicio\": \"HH:MM\",\n *   \"hora_fin\": \"HH:MM\",\n *   \"titulo\": \"string\",\n *   \"asistente\": \"string\"\n * }\n */\n\nconst {\n  persona,\n  fecha,\n  hora_inicio,\n  hora_fin,\n  titulo,\n  asistente,\n} = $json;\n\n// 1) Validaciones básicas\nif (!persona) throw new Error('Falta \"persona\".');\nif (!fecha) throw new Error('Falta \"fecha\" (YYYY-MM-DD).');\nif (!hora_inicio || !hora_fin) throw new Error('Faltan horas: \"hora_inicio\" y/o \"hora_fin\".');\n\n// 2) Mapeo correcto de calendarios (basado en tus nodos existentes)\nconst calendarMap = {\n  'Danny': 'danny.fiborti@gmail.com',\n  'Mauricio': 'mauleon1119@gmail.com', \n  'Fernando': 'fernando.fiborti@gmail.com',\n  'Emilio': 'emilio.fiborti@gmail.com',\n  'Fiborti Team': 'agencia@fiborti.com',\n  'Team Desarrolladores A': 'agencia@fiborti.com',\n  'Team Desarrolladores B': 'agencia@fiborti.com'\n};\n\nconst calendarId = calendarMap[persona];\nif (!calendarId) {\n  throw new Error(`Persona inválida: \"${persona}\". Usa: ${Object.keys(calendarMap).join(', ')}`);\n}\n\n// 3) Construir DateTime\nconst startDateTime = `${fecha}T${hora_inicio}:00`;\nconst endDateTime = `${fecha}T${hora_fin}:00`;\n\n// 4) Armar el recurso del evento\nconst resource = {\n  summary: titulo || 'Cita',\n  description: asistente ? `Agendado por: ${asistente}` : 'Cita agendada desde el sistema',\n  start: { dateTime: startDateTime, timeZone: 'America/Merida' },\n  end: { dateTime: endDateTime, timeZone: 'America/Merida' },\n};\n\n// 5) Devolver formato para el AI Agent\nreturn JSON.stringify({\n  success: true,\n  calendarId,\n  resource,\n  persona,\n  mensaje: `Preparando evento para ${persona} el ${fecha} de ${hora_inicio} a ${hora_fin}`\n});"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.3,
      "position": [
        176,
        464
      ],
      "id": "028ee1df-216d-4e9f-b2dd-94507206439f",
      "name": "Code book_appointment"
    },
    {
      "parameters": {
        "jsCode": "// Este es un Code NORMAL (no tool)\nconst raw = $json.response || '{}';   // el tool mete el texto aquí\nlet data;\ntry {\n  data = JSON.parse(raw);\n} catch {\n  throw new Error('No pude parsear la respuesta del tool: ' + raw);\n}\nreturn [{ json: data }];  // ahora sí sale como objeto usable"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.3,
      "position": [
        384,
        464
      ],
      "id": "4d42dc0e-9853-4441-83f7-855da4439e5f",
      "name": "Function Item"
    },
    {
      "parameters": {
        "jsCode": "/**\n * Convierte el string JSON del tool en objeto utilizable.\n * Entrada típica desde el tool: { response: \"{\\\"persona\\\":[\\\"Danny\\\",\\\"Mauricio\\\"],\\\"fecha\\\":\\\"2025-08-13\\\", ...}\" }\n * Salida: { persona:[...], fecha?, timeMin, timeMax }\n */\n\nlet raw = $json.response ?? $json;   // a veces llega en response, otras como cuerpo entero\nif (typeof raw !== 'string') raw = JSON.stringify(raw);\n\nlet data;\ntry {\n  data = JSON.parse(raw);\n} catch (e) {\n  throw new Error('No pude parsear la respuesta del tool: ' + raw);\n}\nif (data.error) {\n  throw new Error(data.error);\n}\n\n// Asegura tipos esperados\nif (!Array.isArray(data.persona) || !data.timeMin || !data.timeMax) {\n  throw new Error('Respuesta del tool incompleta: ' + JSON.stringify(data));\n}\n\nreturn [{ json: data }];"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.3,
      "position": [
        512,
        464
      ],
      "id": "8a4f55de-7864-480a-9ca1-db5ec5adfa56",
      "name": "Code parse_tool_response"
    },
    {
      "parameters": {
        "calendar": {
          "__rl": true,
          "value": "agencia@fiborti.com",
          "mode": "list",
          "cachedResultName": "agencia@fiborti.com"
        },
        "useDefaultReminders": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Use_Default_Reminders', ``, 'boolean') }}",
        "additionalFields": {}
      },
      "type": "n8n-nodes-base.googleCalendarTool",
      "typeVersion": 1.3,
      "position": [
        1600,
        -16
      ],
      "id": "28c391da-a21b-4a65-8b1d-c854562f5c1f",
      "name": "Create an event Fiborti",
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "b2u1TF8oYkGhKL4w",
          "name": "Connection Calendar Fiborti Agency"
        }
      }
    },
    {
      "parameters": {
        "calendar": {
          "__rl": true,
          "value": "mauleon1119@gmail.com",
          "mode": "list",
          "cachedResultName": "mauleon1119@gmail.com"
        },
        "useDefaultReminders": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Use_Default_Reminders', ``, 'boolean') }}",
        "additionalFields": {}
      },
      "type": "n8n-nodes-base.googleCalendarTool",
      "typeVersion": 1.3,
      "position": [
        1744,
        -16
      ],
      "id": "4c63f51d-8438-4056-8be1-41f6083da692",
      "name": "Create an event Mauricio",
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "qd0hWwTbshF5lYPl",
          "name": "Calendario Mauricio"
        }
      }
    },
    {
      "parameters": {
        "calendar": {
          "__rl": true,
          "value": "danny.fiborti@gmail.com",
          "mode": "list",
          "cachedResultName": "Danny Cen Fiborti"
        },
        "useDefaultReminders": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Use_Default_Reminders', ``, 'boolean') }}",
        "additionalFields": {}
      },
      "type": "n8n-nodes-base.googleCalendarTool",
      "typeVersion": 1.3,
      "position": [
        1888,
        -16
      ],
      "id": "65882649-6e81-4c03-a8a1-47a869b02745",
      "name": "Create an event Danny Cen",
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "LNxifMexHpTzrLbw",
          "name": "Calendar Danny Fiborti"
        }
      }
    },
    {
      "parameters": {
        "operation": "getAll",
        "calendar": {
          "__rl": true,
          "value": "agencia@fiborti.com",
          "mode": "list",
          "cachedResultName": "agencia@fiborti.com"
        },
        "returnAll": "={{ $fromAI('Return_All', ``, 'boolean') }}",
        "timeMin": "={{ $fromAI('After', ``, 'string') }}",
        "timeMax": "={{ $fromAI('timeMax','', 'string') }}",
        "options": {
          "orderBy": "startTime"
        }
      },
      "type": "n8n-nodes-base.googleCalendarTool",
      "typeVersion": 1.3,
      "position": [
        1520,
        400
      ],
      "id": "1454b381-6267-4a74-b660-1dbbdbfccc0c",
      "name": "Get many events Fiborti",
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "b2u1TF8oYkGhKL4w",
          "name": "Connection Calendar Fiborti Agency"
        }
      }
    },
    {
      "parameters": {
        "content": "## Get Events",
        "height": 256,
        "width": 784
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        1456,
        304
      ],
      "typeVersion": 1,
      "id": "0ca1a03d-8b32-4852-a260-9e8f1a7cd1ad",
      "name": "Sticky Note"
    },
    {
      "parameters": {
        "content": "## Create Events",
        "height": 256,
        "width": 800
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        1552,
        -112
      ],
      "typeVersion": 1,
      "id": "605d5c99-3bea-4cbe-9ad1-769947da20e3",
      "name": "Sticky Note1"
    },
    {
      "parameters": {
        "operation": "getAll",
        "calendar": {
          "__rl": true,
          "value": "fernando.fiborti@gmail.com",
          "mode": "list",
          "cachedResultName": "fernando.fiborti@gmail.com"
        },
        "returnAll": "={{ $fromAI('Return_All', ``, 'boolean') }}",
        "timeMin": "={{ $fromAI('timeMin','', 'string') }}",
        "timeMax": "={{ $fromAI('timeMax','', 'string') }}",
        "options": {
          "orderBy": "startTime"
        }
      },
      "type": "n8n-nodes-base.googleCalendarTool",
      "typeVersion": 1.3,
      "position": [
        1968,
        400
      ],
      "id": "f4cfef61-492f-4f1d-b018-f1462a8bc47b",
      "name": "Get many events Fernando",
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "l1fpRaPPyCUdhtbT",
          "name": "Fernando Calendar account"
        }
      }
    },
    {
      "parameters": {
        "operation": "getAll",
        "calendar": {
          "__rl": true,
          "value": "danny.fiborti@gmail.com",
          "mode": "list",
          "cachedResultName": "Danny Cen Fiborti"
        },
        "returnAll": "={{ $fromAI('Return_All', ``, 'boolean') }}",
        "timeMin": "={{ $fromAI('After', ``, 'string') }}",
        "timeMax": "={{ $fromAI('timeMax','', 'string') }}",
        "options": {
          "orderBy": "startTime"
        }
      },
      "type": "n8n-nodes-base.googleCalendarTool",
      "typeVersion": 1.3,
      "position": [
        1680,
        400
      ],
      "id": "b7ec7e92-1635-4393-bf96-1d25957874a5",
      "name": "Get many events Danny Cen",
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "LNxifMexHpTzrLbw",
          "name": "Calendar Danny Fiborti"
        }
      }
    },
    {
      "parameters": {
        "operation": "getAll",
        "calendar": {
          "__rl": true,
          "value": "mauleon1119@gmail.com",
          "mode": "list",
          "cachedResultName": "mauleon1119@gmail.com"
        },
        "returnAll": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Return_All', ``, 'boolean') }}",
        "timeMin": "={{ $fromAI('timeMin','', 'string') }}",
        "timeMax": "={{ $fromAI('timeMax','', 'string') }}",
        "options": {
          "orderBy": "startTime"
        }
      },
      "type": "n8n-nodes-base.googleCalendarTool",
      "typeVersion": 1.3,
      "position": [
        1824,
        400
      ],
      "id": "52e62217-381e-4cb8-98dc-fc6a0b94d5a3",
      "name": "Get many events Mauricio",
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "qd0hWwTbshF5lYPl",
          "name": "Calendario Mauricio"
        }
      }
    },
    {
      "parameters": {
        "content": "## Delete Events",
        "height": 224,
        "width": 704
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        1552,
        -368
      ],
      "typeVersion": 1,
      "id": "62a1cc71-556c-4330-afb5-7f9316e259d5",
      "name": "Sticky Note2"
    },
    {
      "parameters": {
        "content": "## Update Events",
        "height": 224,
        "width": 704
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        1536,
        -640
      ],
      "typeVersion": 1,
      "id": "d24bfba6-cf70-4185-bace-ab38104e44f0",
      "name": "Sticky Note3"
    },
    {
      "parameters": {
        "operation": "delete",
        "calendar": {
          "__rl": true,
          "value": "danny.fiborti@gmail.com",
          "mode": "list",
          "cachedResultName": "Danny Cen Fiborti"
        },
        "eventId": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Event_ID', ``, 'string') }}",
        "options": {}
      },
      "type": "n8n-nodes-base.googleCalendarTool",
      "typeVersion": 1.3,
      "position": [
        1600,
        -304
      ],
      "id": "18115fd5-d581-41ed-a1fb-4120b5a760d1",
      "name": "Delete an event in Google Calendar Danny Cen",
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "LNxifMexHpTzrLbw",
          "name": "Calendar Danny Fiborti"
        }
      }
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "fiborti-availability",
        "responseMode": "responseNode",
        "options": {
          "responseHeaders": {
            "entries": [
              {
                "name": "Access-Control-Allow-Origin",
                "value": "*"
              },
              {
                "name": "Access-Control-Allow-Headers",
                "value": "+"
              },
              {
                "name": "Access-Control-Max-Age",
                "value": "3600"
              }
            ]
          }
        }
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        -208,
        -112
      ],
      "id": "6a1bc5c2-2553-47ae-aef9-68ff472bdc96",
      "name": "Webhook",
      "webhookId": "785e7bc1-8d88-49bc-9caa-a47c7fa2b2b7"
    },
    {
      "parameters": {
        "jsCode": "// Convertir JSON del formulario al formato que espera el AI Agent\nconst formData = $json.body;\n\nconsole.log('Datos recibidos del formulario:', formData);\n\nlet chatInput = '';\n\n// Construir el mensaje para el AI Agent según la acción\nif (formData.action === 'consultar_disponibilidad') {\n  \n  if (formData.colaboradores && Array.isArray(formData.colaboradores)) {\n    // Manejar múltiples colaboradores seleccionados\n    const colaboradores = formData.colaboradores.join(', ');\n    \n    if (formData.colaboradores.length === 1) {\n      chatInput = `Consultar disponibilidad de ${colaboradores} para el ${formData.fecha}`;\n    } else {\n      chatInput = `Consultar disponibilidad de múltiples colaboradores: ${colaboradores} para el ${formData.fecha}`;\n    }\n  } else {\n    // Fallback para formato anterior\n    const persona = formData.persona || 'colaborador no especificado';\n    chatInput = `Consultar disponibilidad de ${persona} para el ${formData.fecha}`;\n  }\n  \n  if (formData.hora) {\n    chatInput += ` a las ${formData.hora}`;\n  }\n  \n  if (formData.modalidad) {\n    chatInput += ` (reunión ${formData.modalidad})`;\n  }\n\n} else if (formData.action === 'agendar_cita') {\n  \n  chatInput = `Agendar cita con ${formData.persona} el ${formData.fecha} de ${formData.hora_inicio} a ${formData.hora_fin}. Título: \"${formData.titulo}\"`;\n  \n  if (formData.asistente) {\n    chatInput += `. Solicitante: ${formData.asistente}`;\n  }\n\n} else {\n  chatInput = 'Solicitud no reconocida del formulario';\n}\n\n// Devolver en el formato que espera el AI Agent\nreturn [{\n  json: {\n    chatInput: chatInput,\n    sessionId: 'form_session_' + Date.now(),\n    source: 'wordpress_form',\n    originalFormData: formData,  // Guardar datos originales por si se necesitan\n    // Datos adicionales para el AI Agent\n    colaboradores: formData.colaboradores || (formData.persona ? [formData.persona] : []),\n    fecha: formData.fecha,\n    hora: formData.hora,\n    modalidad: formData.modalidad\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -32,
        -112
      ],
      "id": "5c96f43c-2fea-4dbf-865c-eae3f095f5dd",
      "name": "Code"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={\n  \"success\": true,\n  \"action\": \"respuesta_ai\",\n  \"mensaje\": \"{{ $json.output }}\",\n  \"disponibilidad\": [\n    {\n      \"hora_inicio\": \"16:00\",\n      \"hora_fin\": \"17:00\",\n      \"disponible\": true,\n      \"evento\": null\n    }\n  ],\n  \"timestamp\": \"{{ new Date().toISOString() }}\"\n}",
        "options": {}
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.4,
      "position": [
        736,
        -336
      ],
      "id": "b95ef8b5-2339-41ad-9ab8-d900b01a92f5",
      "name": "Respond to Webhook"
    },
    {
      "parameters": {
        "calendar": {
          "__rl": true,
          "value": "fernando.fiborti@gmail.com",
          "mode": "list",
          "cachedResultName": "fernando.fiborti@gmail.com"
        },
        "useDefaultReminders": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Use_Default_Reminders', ``, 'boolean') }}",
        "additionalFields": {}
      },
      "type": "n8n-nodes-base.googleCalendarTool",
      "typeVersion": 1.3,
      "position": [
        2032,
        -16
      ],
      "id": "4cf73c6d-f7d5-462f-a4cf-b16dc116b2b7",
      "name": "Create an event Fernando",
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "l1fpRaPPyCUdhtbT",
          "name": "Fernando Calendar account"
        }
      }
    },
    {
      "parameters": {
        "calendar": {
          "__rl": true,
          "value": "emilio.fiborti@gmail.com",
          "mode": "list",
          "cachedResultName": "emilio.fiborti@gmail.com"
        },
        "useDefaultReminders": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Use_Default_Reminders', ``, 'boolean') }}",
        "additionalFields": {}
      },
      "type": "n8n-nodes-base.googleCalendarTool",
      "typeVersion": 1.3,
      "position": [
        2176,
        -16
      ],
      "id": "9033975a-2cd5-47c5-9843-d8e54a9bffc5",
      "name": "Create an event Emilio",
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "Ekun9Zy6a7TeAkNN",
          "name": "Google Calendar account Emilio"
        }
      }
    },
    {
      "parameters": {
        "operation": "getAll",
        "calendar": {
          "__rl": true,
          "value": "emilio.fiborti@gmail.com",
          "mode": "list",
          "cachedResultName": "emilio.fiborti@gmail.com"
        },
        "returnAll": "={{ $fromAI('Return_All', ``, 'boolean') }}",
        "timeMin": "={{ $fromAI('timeMin','', 'string') }}",
        "timeMax": "={{ $fromAI('timeMax','', 'string') }}",
        "options": {
          "orderBy": "startTime"
        }
      },
      "type": "n8n-nodes-base.googleCalendarTool",
      "typeVersion": 1.3,
      "position": [
        2112,
        400
      ],
      "id": "dbf2a963-57cb-46b3-b484-01ecfc21144c",
      "name": "Get many events Emilio",
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "Ekun9Zy6a7TeAkNN",
          "name": "Google Calendar account Emilio"
        }
      }
    }
  ],
  "pinData": {},
  "connections": {
    "Google Gemini Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Simple Memory": {
      "ai_memory": [
        [
          {
            "node": "AI Agent",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code check_availability": {
      "ai_tool": [
        [
          {
            "node": "AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Code book_appointment": {
      "ai_tool": [
        [
          {
            "node": "AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Function Item": {
      "ai_tool": [
        [
          {
            "node": "AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Code parse_tool_response": {
      "ai_tool": [
        [
          {
            "node": "AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Create an event Fiborti": {
      "ai_tool": [
        [
          {
            "node": "AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Create an event Mauricio": {
      "ai_tool": [
        [
          {
            "node": "AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Create an event Danny Cen": {
      "ai_tool": [
        [
          {
            "node": "AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Get many events Fiborti": {
      "ai_tool": [
        [
          {
            "node": "AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Get many events Fernando": {
      "ai_tool": [
        [
          {
            "node": "AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Get many events Danny Cen": {
      "ai_tool": [
        [
          {
            "node": "AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Get many events Mauricio": {
      "ai_tool": [
        [
          {
            "node": "AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Delete an event in Google Calendar Danny Cen": {
      "ai_tool": [
        [
          {
            "node": "AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Webhook": {
      "main": [
        [
          {
            "node": "Code",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code": {
      "main": [
        [
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create an event Fernando": {
      "ai_tool": [
        [
          {
            "node": "AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Create an event Emilio": {
      "ai_tool": [
        [
          {
            "node": "AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Get many events Emilio": {
      "ai_tool": [
        [
          {
            "node": "AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "b5b8b03e-ccac-4c1b-b1f0-49b05a979c0d",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "8bb72653025e5a2505549dfbfca3f4b7b3593ffd0268f18f9403d22b9b22008a"
  },
  "id": "w57ykAkd7PPy0USM",
  "tags": []
}